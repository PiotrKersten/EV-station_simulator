import simpy
import random

import gui
import battery
import grid
import ev
import modules

class Simulation:
    def __init__(self, env):
        self.env = env
        self.gui = gui.Gui()
        try:
            (
                self.time_from, 
                self.time_to, 
                self.station_load_cars, 
                self.station_load_trucks, 
                self.desired_charging_time, 
                self.battery_capacity, 
                self.grid_power, 
                self.average_time,
                self.chargers_quantity,
                self.chargers_power,
            ) = self.gui.insertSimulationParameter()

        except ValueError:
            print('Aborted. Closing app')
            return

        self.grid  = grid.Grid(self.grid_power)
        self.battery = battery.Battery(self.battery_capacity, self.desired_charging_time)
        self.ev = ev.EV()
        self.modules = modules.Modules()

        self.multiplier = 60 // self.desired_charging_time
        module_power = self.chargers_power / self.chargers_quantity 
        self.station_load = self.station_load_cars + self.station_load_trucks
        self.chargers = [simpy.Resource(env, capacity=2) for _ in range(self.chargers_quantity)]
        self.charger_modules = {i: [module_power] * self.chargers_quantity for i in range(self.chargers_quantity * 2)}  


        self.time_table = []
        self.charging_times = []
        self.car_priorities = []
        self.car_queue = []

        self.time_between = random.randint(self.time_from, self.time_to)
        if self.average_time != 0:
            self.time_between = self.average_time
        
        self.env.process(self.run())  

    def run(self):
        processes = []  
        if self.station_load_trucks > 0:
            ratio = self.station_load_cars / self.station_load_trucks
        else:
            ratio = float('inf') 

        cars_count = 0
        trucks_count = 0


        for i in range(self.station_load):

            yield self.env.timeout(self.time_between)
            self.time_table.append(self.time_between)

            if trucks_count < self.station_load_trucks and (cars_count / (trucks_count + 1) >= ratio):
                process = self.env.process(self.stationRun(f'Truck {trucks_count}', 2, i * 1, self.desired_charging_time))
                trucks_count += 1
            else:
                process = self.env.process(self.stationRun(f'Car {cars_count}', 1, i * 1, self.desired_charging_time))
                cars_count += 1
        
    
            processes.append(process)

        yield self.env.all_of(processes)
        self.energy_table=self.ev.getTable()
        self.battery_capacity_data=self.battery.getTable()
        self.grid_power_data=self.grid.getTable()

        self.gui.showSimulationParametersWithPlots(
                                                   self.battery_capacity,
                                                   self.time_table, 
                                                   self.energy_table, 
                                                   self.station_load, 
                                                   self.desired_charging_time, 
                                                   self.charging_times, 
                                                   self.grid_power_data, 
                                                   self.battery_capacity_data)

    def stationRun(self, name, type, arriving_time, charge_duration):
        if type==1:
            vehicle = self.ev.createCar(name, arriving_time, charge_duration)
        else:
            vehicle = self.ev.createTruck(name, arriving_time, charge_duration)
            
        yield self.env.timeout(arriving_time)

        desired_power = vehicle['needed_energy']*self.multiplier

        print("\n")
        print(f"{name} arrived at {arriving_time} [t.u] with energy needed {vehicle['needed_energy']} kWh")
        print(f"Desired power: {desired_power}")

        available_grid = self.grid.checkGridState()
        available_station, available_slot = self.checkStationAvailability(desired_power)
        available_battery = self.battery.checkBatteryState()
        lower_limit = self.battery.getLower()

        print("\n")
        print(f"{name} arrived at {arriving_time} [t.u] with energy needed {vehicle['needed_energy']} kWh")
        print(f"Desired power: {desired_power}")
        print(f"Grid power {available_grid} kW")

        if available_station is not None:
            vehicle['assigned_power'] = desired_power
            vehicle['charger_index'] = available_station
            vehicle['charger_slot'] = available_slot
            

            if desired_power <= available_grid: 

                print(f"Charging with grid only {desired_power} kW")
                power_to_return = desired_power
                self.battery.chargeBattery(available_grid, available_battery, power_to_return)
                battery_power_demand = 0

            elif desired_power > available_grid:

                battery_power_demand = desired_power - available_grid
                energy_demand = battery_power_demand * (1/self.multiplier)
                print(f"Energy demanded {energy_demand}, available battery {available_battery - lower_limit}")

                if  energy_demand > available_battery or (available_battery-energy_demand) < lower_limit:

                    print("Module managing")

                    battery_to_use = (available_battery - lower_limit)*self.multiplier
                    demanded = desired_power - battery_to_use - available_grid

                    print(f"Power demanded from modules: {demanded}")

                    power_to_attach = self.modules.checkModuleToDetach(demanded, self.car_priorities)
                    max_power = power_to_attach + battery_to_use + available_grid
                    if max_power != desired_power:
                        charge_duration = int((vehicle['needed_energy'] / max_power) * 60)
                        print(f"New charging time {charge_duration}")

                    print(f"Charging with grid {available_grid} kW battery: {battery_power_demand} kW modules: {power_to_attach} kW")

                    battery_power_demand = battery_to_use #update to battery state
                else:

                    print("Battery managing")
                    battery_power_demand = desired_power - available_grid
                    print(f"Charging with grid {available_grid} kW and battery {battery_power_demand} kW")

            self.battery.updateBattery(battery_power_demand, False)
            self.grid.updateGridState(available_grid, False)
            power_to_return=available_grid
            

            self.car_priorities.append(vehicle)
            with self.chargers[available_station].request() as req:
                yield req  
                print(f"[{self.env.now}] Vehicle {name} starts charging at charger {available_station} slot {available_slot}")
                charge_duration = self.modules.checkIfModuleDetached(vehicle, charge_duration, self.car_priorities)
                yield self.env.timeout(charge_duration)   
                print(f"[{self.env.now}] Vehicle {name} finished charging at charger {available_station} slot {available_slot}")
                self.grid.updateGridState(power_to_return, True)
            
            
        else:
            print(f"{name} is waiting in queue...")
            self.car_queue.append(vehicle)
            return 
        self.updateData(charge_duration)
        self.car_priorities.remove(vehicle)
        
                    
    def checkStationAvailability(self, desired_power):
        for i, charger in enumerate(self.chargers):
            occupied_slots = charger.count  
            free_slots = charger.capacity - occupied_slots  

            total_power = sum(car['assigned_power'] for car in self.car_priorities if car['charger_index'] == i)

            print(f"Charger {i}: {occupied_slots}/{charger.capacity} slots occupied | Power: {total_power} kW")



            if free_slots > 0 and (total_power + desired_power) <= self.grid_power:
                for slot in range(charger.capacity):
                    if slot >= occupied_slots: 
                        print(f"Found free slot at charger {i}, slot {slot}")
                        return i, slot

        print("No suitable charger available (exceeds power limit or no slots).")
        return None, None


    def updateData(self, time):
        self.battery.insertDataToTable()
        self.grid.insertDataToTable()
        self.charging_times.append(time)
        pass